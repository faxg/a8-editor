const express = require('express');
const expect = require('chai').expect;
var rest = require('rest');


const a8etracer = require('../tracer');

// rest client --> Express Server

describe('trace client (rest) => server (express)', () => {
    it('should return zipkin tracing headers', done => {

        // create express server and add tracing middleware
        const app = express();
        a8etracer.instrumentExpress(app, 'server');

        // use instrumented rest client
        rest = a8etracer.createClient('client');


        // mock server endpoint
        app.get('/api', (req, res) => {
            // return the incoming trace headers as json payload for easy checking
            res.status(202).json({
                status: 'OK',
                traceId: req.header('X-B3-TraceId') || '?',
                spanId: req.header('X-B3-SpanId') || '?'
            });
        });

        // start server
        const server = app.listen(0, () => {
            const port = server.address().port;
            const url = `http://127.0.0.1:${port}/api`;

            // call (instrumented) server from (instrumented) client
            rest(url)
                .then((response) => {
                    //console.log(response);
                    var headers = response.headers;
                    var payload = JSON.parse(response.entity);

                    //console.log(headers);
                    //console.log(payload);


                    expect(response.status.code).to.equal(202);
                    expect(headers['Access-Control-Allow-Origin']).to.equal('*');
                    expect(headers['Access-Control-Allow-Headers']).to.equal('Origin, X-Requested-With, Accept, X-B3-TraceId, X-B3-ParentSpanId, X-B3-SpanId, X-B3-Sampled');

                    // check that traceId and spanId (generated by client) are 16 digit hex
                    expect(payload.traceId).to.match(/^[a-f0-9]{16}$/);
                    expect(payload.traceId).to.match(/^[a-f0-9]{16}$/);


                    server.close();
                    done();
                })
                .catch(err => {
                    server.close();
                    done(err);
                });

        });
    });

});